\subsection{Programa final Unity PRO}

A partir del programa utilizado para obtener los primeros registros, se realizó modificaciones necesarias donde se eliminó y agregó variables de la lista de direcciones que se creyeron necesarias a la hora de implementar el proyecto.\\


\subsubsection{Direcciones utilizadas}
\fcolorbox{red}{yellow}{Las direcciones utilizadas para unity + ifix ponerlo despues de SCADA?}


\subsection{Adquisición de datos}
En el objetivo se propuso que el sistema sea capaz de controlar presión o caudal, para lograr lo estipulado. Como en cualquier sistema de control, es necesario conocer las plantas con las que se trabajará, reconociendo en el banco de pruebas tres plantas observadas en  FIGURA\ref{fig:diag} y que serán llamadas:
\begin{itemize}
	\item PIT001: Presión 1 medida a la salida de la bomba.
	\item PIT002: Presión 2 medida luego de la columna que deiva el fluido.
	\item FT001: Caudal que pasa por presión 2.
\end{itemize}
Para realizar las estimaciones de las plantas del sistema se utilizó el protocolo OPC en conjunto con Matlab. Por medio de OFS, se procedió a crear y configurar un servidor con la dirección correspondiente y se seleccionó el programa realizado en UnityPro donde se encontraban las variables necesarias (Figura \ref{fig:opc1}).

\begin{figure}[htbp]
	\centering
	\subfigure[]{\includegraphics[width=70mm]{ofs1.png}}
	\subfigure[]{\includegraphics[width=70mm]{ofs2.png}}
	\caption{Configuración OPC} \label{fig:opc1}
\end{figure}


Una vez configurado el servidor se abre el programa \textbf{OPC Factory Server} dando inicio al servidor (Figura \ref{fig:opc2}a). Para observar si la comunicación esta establecida de forma correcta, se utilizó el programa \textbf{OFS Client} dónde se debió agregar el tag correspondiente a la variable a observar (Figura \ref{fig:opc2}b)

\begin{figure}[htbp]
	\centering
	\subfigure[OPC Factory Server]{\includegraphics[width=40mm]{ofs3.png}}
	\subfigure[OFS Client]{\includegraphics[width=80mm]{ofs4.png}}
	\caption{Conexión servidor OPC} \label{fig:opc2}
\end{figure}

Una vez corroborada la comunicación con el servidor OPC, se procedió a crear un cliente OPC en Simulink (perteneciente a Matlab) para adquirir y guardar las variables necesarias. 


\subsubsection{Uso de Matlab}
En el entorno Simulink se procedió a configurar un bloque de cliente OPC con la dirección IP donde se encuentra el servidor previamente creado. Luego, para leer las variables necesarias se creó un bloque de lectura OPC (Figura \ref{fig:opcsimu} a) y con un bloque \textit{Scope}, se activó la opción para que se guarden los vectores de las variables a estudiar (Figura \ref{fig:opcsimu} b). 


\begin{figure}[htbp]
	\centering
	\subfigure[]{\includegraphics[width=40mm]{ofs5.png}}
	\subfigure[]{\includegraphics[width=60mm]{ofs6.png}}
	\caption{Cliente OPC en Simulink} \label{fig:opcsimu}
\end{figure}



\subsubsection{Estimación de la planta}

Para realizar la estimación de las plantas se utilizó el método matemático de sistema de primer orden con retardo (Figura \ref{fig:1erorden}), cuya función de transferencia es: \\
\begin{equation}
	G(s)\;=\;\frac K{1\;+\;\tau\;.\;s}e^{-T.s}
\end{equation}


Dónde:
\begin{itemize}
	\item K:  Ganancia del sistema $K = \frac{\triangle y}{\triangle u}$
	\item $\tau$: constante de tiempo
	\item T= Retardo
\end{itemize}

\begin{figure}[htb]
	\centering
	\includegraphics[scale=1]{1erorden.png}
	\captionof{figure}{Sistema de primer orden}
	\label{fig:1erorden}
\end{figure}
Los valores correspondientes de cada elemento para cada planta son los observados en la tabla \ref{tab:parametros} 
\fcolorbox{red}{yellow}{los saque de lectura\_csv\_vs\_mod y de cvs drive}?\\
	\fcolorbox{red}{yellow}{ ver que sistema queda y agregar líneas a las filas y columnas}


	\begin{table}[h]
 \begin{minipage}{\linewidth}
	\centering
	\begin{minipage}{0.45\linewidth}
	
			\centering
			
			\label{tab:parametros}
			\begin{tabular}{|l|l|l|l|}
				\hline
				& PIT001 & PIT002 & FT001 \\ \hline
				Ay & 1.4208 & 13.29 & 4.18 \\ \hline
				Au & 200 & 200 & 300 \\ \hline
				T & 0.6 & 1.1 &  \\ \hline
				$\tau$ & 1.7 & 2 & \\ \hline
			\end{tabular}
			\captionof{table}{Variables para el cálculo de las funciones de transferencia}
	
	\end{minipage}
	\hspace{0.05\linewidth}
	\begin{minipage}{0.45\linewidth}
	
			\centering
		
			\label{tab:pid}
			\begin{tabular}{|l|l|l|l|}
				\hline
				& PIT001 & PIT002 & FT001 \\ \hline
				Kp & ??? & ??? & ??? \\ \hline
				Ki & ??? & ??? & ??? \\ \hline
				Kd & ??? & ??? & ??? \\ \hline
				N & ??? & ??? & ??? \\ \hline
			\end{tabular}
				\captionof{table}{Valores de PID}

	\end{minipage}
\end{minipage}
		\end{table}










Las funciones de transferencia calculadas son:
\fcolorbox{red}{yellow}{poner ecuaciones}

\subsubsection{PID calculado}
El controlador PID de cada planta se calculó con \textit{Tune PID controllers}, dónde se buscó que las respuestas sean \fcolorbox{red}{yellow}{críticamente amortiguado para....}.\\
Los valores obtenidos del software Matlab se muestran en la tabla \ref{tab:pid}, los cuales se ingresaron en los bloques de \textit{UnityPro} con las respectivas modificaciones numéricas según lo establecido por el software.


Se observa que los controladores PID son del tipo proporcional integrador, dando así ya que la ganancia en los diferentes escalones en la planta no era constante. Al utilizar un PI genera una salida con error de estado estacionario cero. 

\begin{comment}
\fcolorbox{red}{yellow}{Estuve viendo las curvas con escalones donde se ve que la ganancia estática se modifica frente a diferentes escalones. Si el objetivo fuese calcular un controlador para ese sistema una buena opción seria un controlador PI. De esta forma, la acción integral va a tratar de hacer que el error de estado estacionario sea cero frente a una entrada escalón. Además, los problemas que pueden existir en el envejecimiento de componentes, errores en el modelado y variaciones en la ganancia estática se van a mitigar con la parte integral del controlador. Obviamente al cambiar la planta la respuesta va a cambiar pero se va a cumplir la consigna de seguir la referencia. Para mostrar esto es posible calcular un controlador para un sistema y luego probar el controlador en los dos sistemas. Eso hice en el pdf que les adjunto con un sistema con 3 polos reales. Más detalles pueden encontrar en el libro de Ogata o Control avanzado de Karl Astrom, capitulo 3.
De esta forma, me da la sensación que para los objetivos de esta materia plantear un controlador PI para un controlador me parece bien.}
\end{comment}



